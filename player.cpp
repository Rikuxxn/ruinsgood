//=============================================================================
//
// プレイヤー処理 [player.cpp]
// Author : RIKU TANEKAWA
//
//=============================================================================

//*****************************************************************************
// インクルードファイル
//*****************************************************************************
#include "player.h"
#include "texture.h"
#include "manager.h"
#include "model.h"
#include "particle.h"
#include "game.h"
#include "stageselect.h"

using namespace std;

//=============================================================================
// コンストラクタ
//=============================================================================
CPlayer::CPlayer(int nPriority) : CObject(nPriority)
{
	// 値のクリア
	m_pos				= INIT_VEC3;					// 位置
	m_ResPos			= {};							// 復活する位置
	m_rot				= INIT_VEC3;					// 向き
	m_rotDest			= INIT_VEC3;					// 向き
	m_move				= INIT_VEC3;					// 移動量
	m_targetMove		= INIT_VEC3;					// 目標速度
	m_currentMove		= INIT_VEC3;					// 実際の移動速度
	m_size				= D3DXVECTOR3(1.0f, 1.0f, 1.0f);// サイズ
	m_mtxWorld			= {};							// ワールドマトリックス
	m_nNumModel			= 0;							// モデル(パーツ)の総数
	m_playerUse			= true;							// 使われているかどうか
	m_pShadowS			= NULL;							// ステンシルシャドウへのポインタ
	m_pMotion			= NULL;							// モーションへのポインタ
	m_currentMotion		= CMotion::TYPE_NEUTRAL;		// 現在のモーション
	m_isJumping			= false;						// ジャンプ中フラグ
	m_bIsMoving			= false;						// 移動入力フラグ
	m_bIsSideMoving		= false;						// 横移動入力フラグ
	m_pRigidBody		= NULL;							// 剛体へのポインタ
	m_bOnGround			= false;						// 接地フラグ
	m_pShape			= NULL;							// 当たり判定の形へのポインタ
	m_pDebug3D			= NULL;							// 3Dデバッグ表示へのポインタ
	m_radius			= 0.0f;							// カプセルコライダーの半径
	m_height			= 0.0f;							// カプセルコライダーの高さ
	m_colliderPos		= INIT_VEC3;					// コライダーの位置
	m_jumpFrame			= 0;							// ジャンプしてから何フレーム経過したか
	m_pCarryingBlock	= NULL;							// 運んでいるブロック
	m_particleTimer		= 0;							// タイマー
	for (int nCnt = 0; nCnt < MAX_PARTS; nCnt++)
	{
		m_apModel[nCnt] = {};						// モデル(パーツ)へのポインタ
	}
}
//=============================================================================
// デストラクタ
//=============================================================================
CPlayer::~CPlayer()
{
	// なし
}
//=============================================================================
// 生成処理
//=============================================================================
CPlayer* CPlayer::Create(D3DXVECTOR3 pos, D3DXVECTOR3 rot)
{
	CPlayer* pPlayer;

	pPlayer = new CPlayer;

	pPlayer->m_pos = pos;
	pPlayer->m_rot = D3DXToRadian(rot);

	// ステージIDの取得
	int stageId = CStageSelect::GetSelectedStage();

	if (stageId == 0)
	{
		// リスポーン位置の設定
		pPlayer->AddRespawnPoint(D3DXVECTOR3(427.0f, 30.0f, 1110.0f));
		pPlayer->AddRespawnPoint(D3DXVECTOR3(-1327.0f, 30.0f, -4586.0f));
		pPlayer->AddRespawnPoint(D3DXVECTOR3(2810.0f, 30.0f, -1518.0f));
		pPlayer->AddRespawnPoint(D3DXVECTOR3(-1380.0f, 30.0f, -6861.7f));
	}
	else if (stageId == 1)
	{
		pPlayer->AddRespawnPoint(D3DXVECTOR3(-1132.0f, 310.0f, 724.5f));
		pPlayer->AddRespawnPoint(D3DXVECTOR3(1132.0f, 310.0f, 724.5f));
		pPlayer->AddRespawnPoint(D3DXVECTOR3(1540.0f, 420.0f, -990.0f));
	}

	// 初期化処理
	pPlayer->Init();

	return pPlayer;
}
//=============================================================================
// 初期化処理
//=============================================================================
HRESULT CPlayer::Init(void)
{
	CModel* pModels[MAX_PARTS];
	int nNumModels = 0;

	// パーツの読み込み
	m_pMotion = CMotion::Load("data/motion.txt", pModels, nNumModels);

	for (int nCnt = 0; nCnt < nNumModels && nCnt < MAX_PARTS; nCnt++)
	{
		m_apModel[nCnt] = pModels[nCnt];

		// オフセット考慮
		m_apModel[nCnt]->SetOffsetPos(m_apModel[nCnt]->GetPos());
		m_apModel[nCnt]->SetOffsetRot(m_apModel[nCnt]->GetRot());
	}

	// パーツ数を代入
	m_nNumModel = nNumModels;

	// プレイヤーが使われている
	m_playerUse = true;

	// 変数の初期化
	m_rot = D3DXVECTOR3(0.0f, -D3DX_PI, 0.0f);

	//*********************************************************************
	// Bullet Physics カプセルコライダーの設定
	//*********************************************************************

	m_radius = 18.5f;
	m_height = 55.5f;

	m_pShape = new btCapsuleShape(m_radius, m_height);

	// コライダー中心 = 足元 + オフセット
	m_colliderPos = m_pos + D3DXVECTOR3(0, 20.0f, 0);

	btTransform transform;
	transform.setIdentity();
	transform.setOrigin(btVector3(m_colliderPos.x, m_colliderPos.y, m_colliderPos.z));

	// 質量を設定
	btScalar mass = 1.0f;
	btVector3 inertia(0, 0, 0);  // 慣性

	m_pShape->calculateLocalInertia(mass, inertia);

	btDefaultMotionState* motionState = new btDefaultMotionState(transform);
	btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, motionState, m_pShape, inertia);

	m_pRigidBody = new btRigidBody(rbInfo);

	m_pRigidBody->setAngularFactor(btVector3(0, 0, 0));
	m_pRigidBody->setFriction(0.0f);// 摩擦
	m_pRigidBody->setRollingFriction(0.0f);// 転がり摩擦

	m_pRigidBody->setUserPointer(this);
	m_pRigidBody->setActivationState(DISABLE_DEACTIVATION);// スリープ状態にしない

	// 物理ワールドに追加
	btDiscreteDynamicsWorld* pWorld = CManager::GetPhysicsWorld();

	if (pWorld != NULL)
	{
		pWorld->addRigidBody(m_pRigidBody);
	}

	// ステンシルシャドウの生成
	m_pShadowS = CShadowS::Create("data/MODELS/stencilshadow.x",m_pos);

	// 初期化時にこのインスタンスのポインタを渡す
	m_stateMachine.Start(this);

	// 初期状態のステートをセット
	m_stateMachine.ChangeState<CPlayer_StandState>();

	return S_OK;
}
//=============================================================================
// 終了処理
//=============================================================================
void CPlayer::Uninit(void)
{
	ReleasePhysics();

	for (int nCnt = 0; nCnt < MAX_PARTS; nCnt++)
	{
		if (m_apModel[nCnt] != NULL)
		{
			m_apModel[nCnt]->Uninit();
			delete m_apModel[nCnt];
			m_apModel[nCnt] = NULL;
		}
	}

	if (m_pMotion != NULL)
	{
		delete m_pMotion;
		m_pMotion = NULL;
	}

	// オブジェクトの破棄(自分自身)
	this->Release();
}
//=============================================================================
// 更新処理
//=============================================================================
void CPlayer::Update(void)
{
	// カメラの取得
	CCamera* pCamera = CManager::GetCamera();

	// カメラの角度の取得
	D3DXVECTOR3 CamRot = pCamera->GetRot();

	// カメラモードの取得
	CCamera::MODE camMode = pCamera->GetMode();

	if (CManager::GetCamera()->GetMode() != CCamera::MODE_DIRECTION)
	{
		// ブロックを持つ処理
		HoldBlock();
	}

	if (!m_isJumping)
	{
		// 接地判定
		m_bOnGround = OnGround(CManager::GetPhysicsWorld(), m_pRigidBody, 55.0f);
	}

	// 入力判定の取得
	InputData input = GatherInput();

	// ステートマシン更新
	m_stateMachine.Update();

	// 向きの正規化
	if (m_rotDest.y - m_rot.y > D3DX_PI)
	{
		m_rot.y += D3DX_PI * 2.0f;
	}
	else if (m_rotDest.y - m_rot.y < -D3DX_PI)
	{
		m_rot.y -= D3DX_PI * 2.0f;
	}

	m_rot.y += (m_rotDest.y - m_rot.y) * 0.09f;

	// 向き更新
	if (camMode == CCamera::MODE_EDIT)
	{
		// 移動入力があればプレイヤー向きを入力方向に
		if (input.moveDir.x != 0.0f || input.moveDir.z != 0.0f ||
			input.sideMoveDir.x != 0.0f || input.sideMoveDir.z != 0.0f)
		{
			m_rotDest.y = atan2f(-input.moveDir.x - input.sideMoveDir.x,
				-input.moveDir.z - input.sideMoveDir.z);
		}
	}
	else
	{
		// カメラ方向に固定
		m_rotDest.y = CamRot.y;
	}

	// 現在位置を物理ワールドから取得して m_pos に反映
	btTransform trans;
	m_pRigidBody->getMotionState()->getWorldTransform(trans);
	btVector3 pos = trans.getOrigin();
	m_colliderPos = D3DXVECTOR3(pos.getX(), pos.getY(), pos.getZ());
	m_pos = m_colliderPos - D3DXVECTOR3(0, 50.0f, 0); // 足元へのオフセット

	if (m_bIsMoving && !m_isJumping && m_bOnGround && !m_bIsSideMoving)
	{
		m_particleTimer++;

		if (m_particleTimer >= DASH_PARTICLE_INTERVAL)
		{
			m_particleTimer = 0;

			// パーティクルの生成
			CParticle::Create(INIT_VEC3,
				m_pos,
				D3DXCOLOR(0.6f, 0.6f, 0.6f, 0.4f),
				25,                    // 寿命
				CParticle::TYPE_MOVE,  // パーティクルタイプ
				1);                    // 数
		}
	}
	else
	{
		m_particleTimer = 0; // 停止時はリセット
	}

	if (m_pos.y < -480.0f)
	{
		// リスポーン処理
		RespawnToCheckpoint();
	}

	if (m_pShadowS != NULL)
	{
		// ステンシルシャドウの位置設定
		m_pShadowS->SetPosition(m_pos);
	}

	int nNumModels = 10;

	// モーションの更新処理
	m_pMotion->Update(m_apModel, nNumModels);
}
//=============================================================================
// 情報の更新処理
//=============================================================================
void CPlayer::UpdateInfo(void)
{
	if (ImGui::TreeNode("Player Info"))
	{
		ImGui::Dummy(ImVec2(0.0f, 10.0f)); // 空白を空ける

		//*********************************************************************
		// POS の調整
		//*********************************************************************

		// 位置
		ImGui::Text("POS"); ImGui::SameLine(70); // ラベル位置微調整

		ImGui::Text("X:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80); // 幅を狭く
		ImGui::DragFloat("##Player_pos_x", &m_pos.x, 1.0f, -1000.0f, 1000.0f, "%.1f");

		ImGui::SameLine();
		ImGui::Text("Y:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_pos_y", &m_pos.y, 1.0f, -1000.0f, 1000.0f, "%.1f");

		ImGui::SameLine();
		ImGui::Text("Z:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_pos_z", &m_pos.z, 1.0f, -1000.0f, 1000.0f, "%.1f");

		//*********************************************************************
		// ROT の調整
		//*********************************************************************

		ImGui::Dummy(ImVec2(0.0f, 10.0f)); // 空白を空ける

		// 向き
		ImGui::Text("ROT"); ImGui::SameLine(70); // ラベル位置微調整

		ImGui::Text("X:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80); // 幅を狭く
		ImGui::DragFloat("##Player_rot_x", &m_rot.x, 0.1f, -D3DX_PI, D3DX_PI, "%.1f");

		ImGui::SameLine();
		ImGui::Text("Y:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_rot_y", &m_rot.y, 0.1f, -D3DX_PI, D3DX_PI, "%.1f");

		ImGui::SameLine();
		ImGui::Text("Z:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_rot_z", &m_rot.z, 0.1f, -D3DX_PI, D3DX_PI, "%.1f");

		//*********************************************************************
		// SIZE の調整
		//*********************************************************************

		ImGui::Dummy(ImVec2(0.0f, 10.0f)); // 空白を空ける

		// ラベル
		ImGui::Text("SIZE"); ImGui::SameLine(70); // ラベルの位置ちょっと調整

		// X
		ImGui::Text("X:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_size_x", &m_size.x, 0.1f, -100.0f, 100.0f, "%.1f");

		// Y
		ImGui::SameLine();
		ImGui::Text("Y:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_size_y", &m_size.y, 0.1f, -100.0f, 100.0f, "%.1f");

		// Z
		ImGui::SameLine();
		ImGui::Text("Z:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_size_z", &m_size.z, 0.1f, -100.0f, 100.0f, "%.1f");

		//*********************************************************************
		// カプセルコライダー の調整
		//*********************************************************************

		ImGui::Dummy(ImVec2(0.0f, 10.0f)); // 空白を空ける

		// ラベル
		ImGui::Text("Capsule Collider"); // ラベルの位置ちょっと調整

		ImGui::Dummy(ImVec2(0.0f, 10.0f)); // 空白を空ける

		// 半径
		ImGui::Text("Radius:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_Radius", &m_radius, 0.1f, -500.0f, 500.0f, "%.1f");

		// 高さ
		ImGui::Text("Height:"); ImGui::SameLine();
		ImGui::SetNextItemWidth(80);
		ImGui::DragFloat("##Player_Height", &m_height, 0.1f, -500.0f, 500.0f, "%.1f");

		ImGui::TreePop(); // 閉じる
	}

	// カプセルコライダー更新チェック
	static float oldRadius = -1.0f;
	static float oldHeight = -1.0f;

	if (m_radius != oldRadius || m_height != oldHeight)
	{
		// 既存のコリジョン形状を削除
		if (m_pShape)
		{
			delete m_pShape;
			m_pShape = NULL;
		}

		// 新しい Capsule Shape を作成
		m_pShape = new btCapsuleShape(m_radius, m_height);

		// リジッドボディに反映
		if (m_pRigidBody)
		{
			m_pRigidBody->setCollisionShape(m_pShape);
		}

		// 値を記録
		oldRadius = m_radius;
		oldHeight = m_height;
	}

}
//=============================================================================
// 描画処理
//=============================================================================
void CPlayer::Draw(void)
{
	// デバイスの取得
	CRenderer* renderer = CManager::GetRenderer();
	LPDIRECT3DDEVICE9 pDevice = renderer->GetDevice();

	// 計算用マトリックス
	D3DXMATRIX mtxRot, mtxTrans, mtxSize;

	// ワールドマトリックスの初期化
	D3DXMatrixIdentity(&m_mtxWorld);

	// サイズを反映
	D3DXMatrixScaling(&mtxSize, m_size.x, m_size.y, m_size.z);
	D3DXMatrixMultiply(&m_mtxWorld, &m_mtxWorld, &mtxSize);

	// 向きを反映
	D3DXMatrixRotationYawPitchRoll(&mtxRot, m_rot.y, m_rot.x, m_rot.z);
	D3DXMatrixMultiply(&m_mtxWorld, &m_mtxWorld, &mtxRot);

	// 位置を反映
	D3DXMatrixTranslation(&mtxTrans, m_pos.x, m_pos.y, m_pos.z);
	D3DXMatrixMultiply(&m_mtxWorld, &m_mtxWorld, &mtxTrans);

	// ワールドマトリックスを設定
	pDevice->SetTransform(D3DTS_WORLD, &m_mtxWorld);

	for (int nCntMat = 0; nCntMat < m_nNumModel; nCntMat++)
	{
		// モデル(パーツ)の描画
		if (m_apModel[nCntMat])
		{
			m_apModel[nCntMat]->Draw();
		}
	}

#ifdef _DEBUG

	// カプセルコライダーの描画
	if (m_pRigidBody && m_pShape)
	{
		btTransform transform;
		m_pRigidBody->getMotionState()->getWorldTransform(transform);

		m_pDebug3D->DrawCapsuleCollider((btCapsuleShape*)m_pShape, transform, D3DXCOLOR(1, 1, 1, 1));
	}

#endif

}
//=============================================================================
// レイによる接触判定
//=============================================================================
bool CPlayer::OnGround(btDiscreteDynamicsWorld* world, btRigidBody* playerBody, float rayLength)
{
	btTransform trans;
	playerBody->getMotionState()->getWorldTransform(trans);

	btVector3 start = trans.getOrigin();
	btVector3 end = start - btVector3(0, rayLength, 0);

	struct RayResultCallback : public btCollisionWorld::ClosestRayResultCallback
	{
		RayResultCallback(const btVector3& from, const btVector3& to)
			: btCollisionWorld::ClosestRayResultCallback(from, to) {}
	};

	RayResultCallback rayCallback(start, end);
	world->rayTest(start, end, rayCallback);

	if (rayCallback.hasHit())
	{// 接触
		return true;
	}

	return false;
}
//=============================================================================
// Physicsの破棄
//=============================================================================
void CPlayer::ReleasePhysics(void)
{
	if (m_pRigidBody)
	{
		btDiscreteDynamicsWorld* pWorld = CManager::GetPhysicsWorld();
		if (pWorld) pWorld->removeRigidBody(m_pRigidBody);
		delete m_pRigidBody->getMotionState();
		delete m_pRigidBody;
		m_pRigidBody = NULL;
	}

	if (m_pShape)
	{
		delete m_pShape;
		m_pShape = NULL;
	}
}
//=============================================================================
// ブロックを持つ処理
//=============================================================================
void CPlayer::HoldBlock(void)
{
	// マウスの取得
	CInputMouse* pInputMouse = CManager::GetInputMouse();

	// ジョイパッドの取得
	CInputJoypad* pInputJoypad = CManager::GetInputJoypad();

	CParticle* pParticle = NULL;

	if (pInputMouse->GetPress(0) || pInputJoypad->GetPressR2())
	{
		if (!m_pCarryingBlock)
		{
			CBlock* target = FindFrontBlockByRaycast(50.0f);// レイの長さを設定

			if (!target)
			{
				return;
			}

			// ブロックの質量を取得
			float blockMass = target->GetMass();

			// ブロックのサイズ(拡大率)を取得
			D3DXVECTOR3 blocksize = target->GetSize();// 拡大率

			float maxsize = 2.0f;

			bool isTooLarge =
				blocksize.x >= maxsize ||
				blocksize.y >= maxsize ||
				blocksize.z >= maxsize;

			if (blockMass > 7.0f || isTooLarge)
			{// 一定質量を超えたら または 一定サイズを超えたら
				return;
			}

			int stageId = CStageSelect::GetSelectedStage();
			if (stageId == 0 && (target->GetType() == CBlock::TYPE_BLOCK3 || target->GetType() == CBlock::TYPE_TORCH2))
			{
				return;
			}

			m_pCarryingBlock = target;

			if (m_pCarryingBlock->GetAngularFactor() == btVector3(0.0f, 0.0f, 0.0f))
			{
				// 無回転
				m_pCarryingBlock->GetRigidBody()->setAngularFactor(m_pCarryingBlock->GetAngularFactor());
			}
			else
			{
				// Y軸のみ回転
				m_pCarryingBlock->GetRigidBody()->setAngularFactor(btVector3(0.0f, 1.0f, 0.0f));
			}
		}
		else
		{
			btRigidBody* pRigid = m_pCarryingBlock->GetRigidBody();

			if (!pRigid || !m_pCarryingBlock->IsDynamicBlock())
			{
				return;
			}

			// 現在の位置
			D3DXVECTOR3 currentPos = m_pCarryingBlock->GetPos();
			D3DXVECTOR3 playerPos = GetPos();

			// 距離チェック
			D3DXVECTOR3 diff = currentPos - playerPos;
			float distance = D3DXVec3Length(&diff);
			const float maxCarryDistance = 200.0f; // 離し上限距離(この距離を超えたらブロックを離す)

			if (distance > maxCarryDistance || currentPos <= playerPos)
			{
				// 離す
				//m_pCarryingBlock->GetRigidBody()->setAngularFactor(btVector3(1.0f, 1.0f, 1.0f));
				m_pCarryingBlock = NULL;
				return;
			}

			float ftargetDis = m_pCarryingBlock->CarryTargetDis();// 離す距離(持ち上げたときの目標距離)

			D3DXVECTOR3 targetPos;// 持ち上げたいターゲット位置
			
			if (m_pCarryingBlock->GetType() == CBlock::TYPE_MOVE_FIRE_STATUE ||
				m_pCarryingBlock->GetType() == CBlock::TYPE_BLOCK3)
			{
				// XZのみ追従、Yは固定
				targetPos = currentPos;
				targetPos.x = playerPos.x + GetForward().x * ftargetDis;
				targetPos.z = playerPos.z + GetForward().z * ftargetDis;
				targetPos.y = currentPos.y; // 高さを変えない
			}
			else
			{
				// 通常は前方に持ち上げる
				targetPos = playerPos + GetForward() * ftargetDis;
				targetPos.y = GetPos().y + 70.0f; // 通常は持ち上げる

				// パーティクル生成
				pParticle = CParticle::Create(INIT_VEC3, targetPos, D3DXCOLOR(0.6f, 1.0f, 0.4f, 1.0f), 50, CParticle::TYPE_FLOATING, 1);
			}

			// Bullet用の差分
			btVector3 posDiff(
				targetPos.x - currentPos.x,
				targetPos.y - currentPos.y,
				targetPos.z - currentPos.z
			);

			// 現在の速度
			btVector3 vel = pRigid->getLinearVelocity();

			// スプリング定数・減衰係数（調整用）
			const float stiffness = 300.0f;  // バネの強さ
			const float damping = 30.0f;   // 減衰の強さ

			// スプリング＋ダンパー力 = -kX - cV
			btVector3 springForce = posDiff * stiffness;
			btVector3 dampingForce = vel * -damping;
			btVector3 totalForce = springForce + dampingForce;

			// 力を加える
			pRigid->applyCentralForce(totalForce);

			// 横の速度を抑えて安定させる（オプション）
			vel.setX(vel.getX() * 1.0f);
			vel.setZ(vel.getZ() * 1.0f);
			pRigid->setLinearVelocity(vel);

			// 回転も抑えると安定する
			pRigid->setAngularVelocity(btVector3(0, 0, 0));
		}
	}
	else
	{
		if (m_pCarryingBlock)
		{
			// 回転制限解除
			m_pCarryingBlock->GetRigidBody()->setAngularFactor(m_pCarryingBlock->GetAngularFactor());

			m_pCarryingBlock = NULL;
		}
	}
}
//=============================================================================
// プレイヤーの前方ベクトル取得
//=============================================================================
D3DXVECTOR3 CPlayer::GetForward(void) const
{
	// プレイヤーの回転角度（Y軸）から前方ベクトルを計算
	float yaw = m_rot.y;

	D3DXVECTOR3 forward(-sinf(yaw), 0.0f, -cosf(yaw));

	// 正規化する
	D3DXVec3Normalize(&forward, &forward);

	return forward;
}
//=============================================================================
// プレイヤーの前方レイ判定処理
//=============================================================================
CBlock* CPlayer::FindFrontBlockByRaycast(float rayLength)
{
	btDiscreteDynamicsWorld* world = CManager::GetPhysicsWorld();

	if (!world)
	{
		return NULL;
	}

	D3DXVECTOR3 from = GetPos() + D3DXVECTOR3(0.0f,20.0f,0.0f);
	D3DXVECTOR3 to = from + GetForward() * rayLength;

	btVector3 btFrom(from.x, from.y, from.z);
	btVector3 btTo(to.x, to.y, to.z);

	struct RayResultCallback : public btCollisionWorld::ClosestRayResultCallback
	{
		RayResultCallback(const btVector3& from, const btVector3& to)
			: btCollisionWorld::ClosestRayResultCallback(from, to) {}

		virtual btScalar addSingleResult(btCollisionWorld::LocalRayResult& rayResult, bool normalInWorldSpace)
		{
			// ブロック以外を無視する場合はここでフィルターしてもいい
			return ClosestRayResultCallback::addSingleResult(rayResult, normalInWorldSpace);
		}
	};

	RayResultCallback rayCallback(btFrom, btTo);
	world->rayTest(btFrom, btTo, rayCallback);

	if (rayCallback.hasHit())
	{
		void* userPtr = rayCallback.m_collisionObject->getUserPointer();

		if (userPtr)
		{
			CBlock* pBlock = static_cast<CBlock*>(userPtr);

			if (pBlock->IsDynamicBlock())
			{
				return pBlock; // 動的なブロックが前方にあった
			}
		}
	}

	return NULL;
}
//=============================================================================
// リスポーン(一番近い位置)処理
//=============================================================================
void CPlayer::RespawnToCheckpoint(void)
{
	if (CManager::GetMode() != MODE_GAME)
	{
		return;
	}

	D3DXVECTOR3 respawnPos = GetNearestRespawnPoint(); // 任意の保存位置

	m_pos = respawnPos;

	btRigidBody* pRigid = GetRigidBody();

	if (pRigid)
	{
		pRigid->setLinearVelocity(btVector3(0, 0, 0));
		pRigid->setAngularVelocity(btVector3(0, 0, 0));

		// ワールド座標更新
		btTransform trans;
		trans.setIdentity();
		trans.setOrigin(btVector3(respawnPos.x, respawnPos.y, respawnPos.z));

		pRigid->setWorldTransform(trans);

		if (pRigid->getMotionState())
		{
			pRigid->getMotionState()->setWorldTransform(trans);
		}
	}
}
//=============================================================================
// リスポーン(直接設定)処理
//=============================================================================
void CPlayer::RespawnToCheckpoint(D3DXVECTOR3 pos)
{
	if (CManager::GetMode() != MODE_GAME)
	{
		return;
	}

	D3DXVECTOR3 respawnPos = pos; // 任意の位置

	m_pos = respawnPos;

	btRigidBody* pRigid = GetRigidBody();

	if (pRigid)
	{
		pRigid->setLinearVelocity(btVector3(0, 0, 0));
		pRigid->setAngularVelocity(btVector3(0, 0, 0));

		// ワールド座標更新
		btTransform trans;
		trans.setIdentity();
		trans.setOrigin(btVector3(respawnPos.x, respawnPos.y, respawnPos.z));

		pRigid->setWorldTransform(trans);

		if (pRigid->getMotionState())
		{
			pRigid->getMotionState()->setWorldTransform(trans);
		}
	}
}
//=============================================================================
// リスポーン位置の追加処理
//=============================================================================
void CPlayer::AddRespawnPoint(const D3DXVECTOR3& pos)
{
	m_ResPos.push_back(pos);
}
//=============================================================================
// 一番近いリスポーン位置を返す処理
//=============================================================================
D3DXVECTOR3 CPlayer::GetNearestRespawnPoint(void) const
{
	if (m_ResPos.empty())
	{
		return m_pos; // 何も登録されていない場合は今の位置
	}

	float minDistSq = FLT_MAX;
	D3DXVECTOR3 nearest = m_ResPos[0];

	for (const auto& pt : m_ResPos)
	{
		D3DXVECTOR3 diff = pt - m_pos;
		float distSq = D3DXVec3LengthSq(&diff);

		if (distSq < minDistSq)
		{
			minDistSq = distSq;
			nearest = pt;
		}
	}

	return nearest;
}
//=============================================================================
// 補間関数
//=============================================================================
D3DXVECTOR3 CPlayer::Lerp(const D3DXVECTOR3& a, const D3DXVECTOR3& b, float t)
{
	return a + (b - a) * t;
}
//=============================================================================
// モーションの設定処理
//=============================================================================
void CPlayer::SetMotion(CMotion::TYPE type, int nBlendFrame)
{
	m_pMotion->StartBlendMotion(type, nBlendFrame);
	m_currentMotion = type;
}
//=============================================================================
// 入力判定取得関数
//=============================================================================
InputData CPlayer::GatherInput(void)
{
	InputData input{};
	input.moveDir = D3DXVECTOR3(0, 0, 0);
	input.sideMoveDir = D3DXVECTOR3(0, 0, 0);
	input.jump = false;

	CInputKeyboard* pKeyboard = CManager::GetInputKeyboard();	// キーボードの取得
	CInputJoypad* pJoypad = CManager::GetInputJoypad();			// ジョイパッドの取得
	XINPUT_STATE* pStick = CInputJoypad::GetStickAngle();		// スティックの取得
	CCamera* pCamera = CManager::GetCamera();					// カメラの取得
	D3DXVECTOR3 CamRot = pCamera->GetRot();						// カメラ角度の取得

	// ---------------------------
	// ジャンプ入力
	// ---------------------------
	if (pKeyboard->GetTrigger(DIK_SPACE) || pJoypad->GetTrigger(pJoypad->JOYKEY_A))
	{
		input.jump = true;
	}

	// ---------------------------
	// ゲームパッド入力
	// ---------------------------
	if (pJoypad->GetStick() && pStick)
	{
		float stickX = pStick->Gamepad.sThumbLX;
		float stickY = pStick->Gamepad.sThumbLY;
		float magnitude = sqrtf(stickX * stickX + stickY * stickY);
		const float DEADZONE = 10922.0f;

		if (magnitude >= DEADZONE)
		{
			stickX /= magnitude;
			stickY /= magnitude;
			float normMag = std::min((magnitude - DEADZONE) / (32767.0f - DEADZONE), 1.0f);
			stickX *= normMag;
			stickY *= normMag;

			D3DXVECTOR3 dir;
			float yaw = CamRot.y;

			dir.x = -(stickX * cosf(yaw) + stickY * sinf(yaw));
			dir.z = stickX * sinf(-yaw) + stickY * cosf(yaw);
			dir.z = -dir.z;

			if (fabsf(stickX) > 0.5f && fabsf(stickY) < 0.3f)
			{
				input.sideMoveDir += D3DXVECTOR3(dir.x, 0, dir.z);
			}
			else
			{
				input.moveDir += D3DXVECTOR3(dir.x, 0, dir.z);
			}
		}
	}

	// ---------------------------
	// キーボード入力
	// ---------------------------
	if (pKeyboard->GetPress(DIK_W))
	{
		input.moveDir += D3DXVECTOR3(-sinf(CamRot.y), 0, -cosf(CamRot.y));
	}
	if (pKeyboard->GetPress(DIK_S))
	{
		input.moveDir += D3DXVECTOR3(sinf(CamRot.y), 0, cosf(CamRot.y));
	}
	if (pKeyboard->GetPress(DIK_A))
	{
		input.sideMoveDir += D3DXVECTOR3(cosf(CamRot.y), 0, -sinf(CamRot.y));
	}
	if (pKeyboard->GetPress(DIK_D))
	{
		input.sideMoveDir += D3DXVECTOR3(-cosf(CamRot.y), 0, sinf(CamRot.y));
	}

	// 正規化
	if (input.moveDir.x != 0.0f || input.moveDir.z != 0.0f)
	{
		D3DXVec3Normalize(&input.moveDir, &input.moveDir);
	}

	if (input.sideMoveDir.x != 0.0f || input.sideMoveDir.z != 0.0f)
	{
		D3DXVec3Normalize(&input.sideMoveDir, &input.sideMoveDir);
	}

	return input;
}

